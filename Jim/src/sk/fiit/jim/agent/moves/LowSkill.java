package sk.fiit.jim.agent.moves;

import static sk.fiit.jim.log.LogType.LOW_SKILL;

import java.util.LinkedList;
import java.util.List;

import sk.fiit.jim.agent.communication.Communication;
import sk.fiit.jim.agent.models.EnvironmentModel;
import sk.fiit.jim.agent.skills.HighSkill;
import sk.fiit.jim.log.Log;
import sk.fiit.jim.log.LogType;

/**
 * Represents a low skill - a basic move like walking or turning, that forms the basis
 * of the agent's movement. 
 *---
 *  <p>Represents a collection of phases (represented by {@link Phase}), plus intelligent
 *  switching between those phases. An instance of LowSkill comes into
 *  play when HighSkill.pickLowSkill returns this instance as a result.</p>
 *  
 *  <p>LowSkill is populated by values contained in an XML. It must possess
 *  a name and an initial phase. Transition between phases is based on temporal
 *  events coming from the server. A low skill can be in one of two states:
 *  either it is finalizing or not. Finalization is triggered by
 *  {@link HighSkill}'s execute() method. It is triggered when this instance
 *  of LowSkill has reached the phase with isFinal flag set to true. If
 *  {@link HighSkill}'s pickLowSkill method chooses another LowSkill,
 *  a finalization of this LowSkill is executed. The objective of finalization
 *  is to get the player in basic stance.</p>
 *  
 *  <p>Every time a new phase is executed, a new target state is calculated by
 *  {@link JointPlacement}. The message sent to the server is generated by
 *  {@link JointPlacement} as well.</p>
 *  
 *@Title	Jim
 *@author	marosurbanec
 *@author	Androids
 */
public class LowSkill{
	/**
	 * Name of low skill. Must be unique.
	 */
	public String name;
	/**
	 * Name of the initial phase of this low skill.
	 */
	public String initialPhase;
	private List<String> types = new LinkedList<String>();
	private String author;
	private String extendedFromMove;
	private String description;
	
	/**
	 * Currently active phase of the low skill.
	 */
	public Phase activePhase;
	private double nextTimePhaseEnds = 0.0;
	private boolean started = false;
	private boolean finalizing = false; //added by Androids - helped by JIM developers
	
	public LowSkill(){
	}
	
	public LowSkill(String name, String initialPhase){
		super();
		this.name = name;
		this.initialPhase = initialPhase;
	}
	
	/**
	 * Starts the finalization process of low skill and 
	 * final phase is set. 
	 *
	 */
	public void executeFinalisation(){
		if (!activePhase.isFinal || !phaseEnded())
			return; //toto by mozno chcelo zalogovat
		
		setNewActivePhase(activePhase.finalizationPhase);
		
		finalizing = true;
	}
	
	/**
	 * Resets all attributes to initial values as in the beginning of low skill.
	 *
	 */
	public void reset(){
		this.activePhase = null;
		this.nextTimePhaseEnds = 0.0;
		this.started = false;
		finalizing = false;
	}
	
	/**
	 * Sets next phase of low skill. If low skill is in final phase, 
	 * finalization is executed.  
	 *
	 */
	public void step() {		
		if (activePhase == null)
			setNewActivePhase(initialPhase);

		if (phaseEnded()) {
			if (activePhase.next != null) {
				setNewActivePhase(activePhase.next);
			}else if (activePhase.next == null && activePhase.isFinal) {
				executeFinalisation();
			}
		}
		
		Log.debug(LOW_SKILL, "Currently active phase: %s", activePhase.name);
		JointPlacement.generateMessage();
		Communication.getInstance().addToMessage(JointPlacement.lastMessage);
	}
	
	private void setNewActivePhase(String phaseName){
		if (shouldSetTrueFlag())
			SkipFlags.setTrue(activePhase.setFlagTrue);
		activePhase = Phases.get(phaseName);
		//TODO possible stack overflow if all the phases have the same skipIfFlag
		if (canSkipThisPhase()){
			setNewActivePhase(activePhase.next);
			return;
		}
		if (shouldSetFalseFlag())
			SkipFlags.setFalse(activePhase.setFlagFalse);
		
		nextTimePhaseEnds = EnvironmentModel.SIMULATION_TIME + activePhase.duration;
		Log.log(LogType.LOW_SKILL, "Starting phase %s", activePhase.name);
		JointPlacement.calculateNewTargetState(activePhase);
	}
	
	private boolean shouldSetTrueFlag(){
		return activePhase != null && activePhase.setFlagTrue != null;
	}	
	
	private boolean canSkipThisPhase(){
		return SkipFlags.isTrue(activePhase.skipIfFlag);
	}
	
	private boolean shouldSetFalseFlag(){
		return activePhase.setFlagFalse != null;
	}

	/**
	 * Returns true if finalization of low skill is possible
	 * at the moment, otherwise false. 
	 *
	 * @return
	 */
	public boolean canFinalize(){
		return phaseEnded() && activePhase != null && activePhase.isFinal;
	}

	private boolean phaseEnded(){
		return (EnvironmentModel.SIMULATION_TIME - nextTimePhaseEnds) > -0.01d;
	}
	
	/**
	 * Returns true if low skill is finalizing, otherwise false. 
	 */
	public boolean isFinalizing() {
		return finalizing;
	}
	
	/**
	 * Returns the name of this low skill. The name must be unique.
	 */
	@Override
	public String toString(){
		return name;
	}

	public List<String> getType() {
		return types;
	}

	public void setType(List<String> type) {
		this.types = type;
	}

	public String getAuthor() {
		return author;
	}

	public void setAuthor(String author) {
		this.author = author;
	}

	public String getExtendedFromMove() {
		return extendedFromMove;
	}

	public void setExtendedFromMove(String extendedFromMove) {
		this.extendedFromMove = extendedFromMove;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	/**
	 * Returns name, initial phase, types, author, extended from move, description,
	 * active phase, next time phase ends, started and finalizing attributes.
	 * 
	 * TODO: is this even used? in ruby scripts? in tf?
	 */
	public String toString2() {
		return "LowSkill [name=" + name + ", initialPhase=" + initialPhase
				+ ", types=" + types + ", author=" + author
				+ ", extendedFromMove=" + extendedFromMove + ", description="
				+ description + ", activePhase=" + activePhase
				+ ", nextTimePhaseEnds=" + nextTimePhaseEnds + ", started="
				+ started + ", finalizing=" + finalizing + "]";
	}
}